%%%% ijcai19.tex

\typeout{IJCAI-19 Instructions for Authors}

% These are the instructions for authors for IJCAI-19.

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in
% The file ijcai19.sty is NOT the same than previous years'
\usepackage{ijcai19}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algorithmic}
\urlstyle{same}

%%%%%%%%%%%%%%%%%% Added for this paper
\usepackage{ wasysym }
\newcommand{\tup}[1]{{\langle #1 \rangle}}
\newcommand{\pre}{\mathsf{pre}}     % precondition
\newcommand{\del}{\mathsf{del}}     % effect
\newcommand{\add}{\mathsf{add}}     % effect
\newcommand{\eff}{\mathsf{eff}}     % effect
\newcommand{\cond}{\mathsf{cond}}   % conditional effect
\newcommand{\true}{\mathsf{true}}   % true
\newcommand{\false}{\mathsf{false}} % false
\newcommand{\PE}{\mathrm{PE}}     % precondition
\newcommand{\strips}{\textsc{Strips}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}

%%%%%%%%%%%%%55


% the following package is optional:
%\usepackage{latexsym} 

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.

\title{Computing {\em the least commitment} action model from state observations}

% Single author syntax
%\author{
%    Sarit Kraus
%    \affiliations
%    Department of Computer Science, Bar-Ilan University, Israel \emails
%    pcchair@ijcai19.org
%}

% Multiple author syntax (remove the single-author syntax above and the \iffalse ... \fi here)
% Check the ijcai19-multiauthor.tex file for detailed instructions
\author{
Diego Aineto$^1$\and
Sergio Jim\'enez$^1$\and
Eva Onaindia$^1$\And
\and
Blai Bonet$^2$
\affiliations
$^1${\small Departamento de Sistemas Inform\'aticos y Computaci\'on. Universitat Polit\`ecnica de Val\`encia. Valencia, Spain}\\
$^2${\small Departamento de Computaci\'on. Universidad Sim\'on Bol√≠var. Caracas, Venezuela}
\emails
{\scriptsize \{dieaigar,serjice,onaindia\}@dsic.upv.es, bonet@usb.ve}}



\begin{document}

\maketitle

\begin{abstract}
  
\end{abstract}

\section{Introduction}
Given a sequence of partially observed states, this paper formalizes the task of computing the exact set of action models that are {\em conformant} with the given observation. This task is of interest because it allows to, incrementally and scalably, learn action models from arbitrary large sets of state observations.

In addition, the paper presets a new method to compute {\em the least commitment} action model from state observations. The method assumes that action models are specified as \strips\ action schema and builds on top of off-the-shelf {\em conformant planning} algorithms.



\section{Background}
This section formalizes the {\em classical} and {\em conformant} planning models as well as the kind of input observations for the computation of {\em the least commitment} action model.

\subsection{Classical planning with conditional effects}
$F$ is the set of {\em fluents} or {\em state variables} (propositional variables). A {\em literal} $l$ is a valuation of a fluent $f\in F$, i.e. either~$l=f$ or $l=\neg f$. $L$ is a set of literals that represents a partial assignment of values to fluents, and $\mathcal{L}(F)$ is the set of all literals sets on $F$, i.e.~all partial assignments of values to fluents. A {\em state} $s$ is a full assignment of values to fluents. We explicitly include negative literals $\neg f$ in states s.t. $|s|=|F|$ and the size of the state space is $2^{|F|}$.

A {\em planning frame} is a tuple $\Phi=\tup{F,A}$, where $F$ is a set of fluents and $A$ is a set of \emph{actions}. An action $a\in A$ is defined with {\em preconditions}, $\pre(a)\in\mathcal{L}(F)$, {\em positive effects}, $\eff^+(a)\in\mathcal{L}(F)$, and {\em negative effects} $\eff^-(a)\in\mathcal{L}(F)$. The semantics of actions $a\in A$ is specified with two functions: $\rho(s,a)$ denotes whether action $a$ is {\em applicable} in a state $s$ and $\theta(s,a)$ denotes the {\em successor state} that results of applying action $a$ in a state $s$. Then, $\rho(s,a)$ holds iff $\pre(a)\subseteq s$. And the result of applying $a$ in $s$ is $\theta(s,a)=\{s\setminus\eff^-(a))\cup\eff^+(a)\}$.

A {\em classical planning problem} is a tuple $P=\tup{F,A,I,G}$, where $I$ is the initial state in which all the fluents of $F$ are assigned a {\em true\textbar false} value and $G\in\mathcal{L}(F)$ is the set of goal conditions over the state variables. A {\em plan} $\pi$ for $P$ is an action sequence $\pi=\tup{a_1, \ldots, a_n}$, and $|\pi|=n$ denotes its {\em plan length}. The execution of $\pi$ in the initial state $I$ of $P$ induces a {\em trajectory} $\tau(\pi,s_0)=\tup{s_0, a_1, s_1, \ldots, a_n, s_n}$ such that $s_0=I$ and, for each {\small $1\leq i\leq n$}, it holds $\rho(s_{i-1},a_i)$ and $s_i=\theta(s_{i-1},a_i)$. A plan $\pi$ solves $P$ iff the induced {\em trajectory} $\tau(\pi,s_0)$ reaches a final state $G \subseteq s_n$.

An action $a_c\in A$ with conditional effects is defined as a set of preconditions $\pre(a_c)\in\mathcal{L}(F)$ and a set of {\em conditional effects} $\cond(a_c)$. Each conditional effect $C\rhd E\in\cond(a_c)$ is composed of two sets of literals: $C\in\mathcal{L}(F)$, the {\em condition}, and $E\in\mathcal{L}(F)$, the {\em effect}. An action $a_c$ is applicable in a state $s$ if $\rho(s,a_c)$ is true, and the {\em triggered effects} resulting from the action application are the effects whose conditions hold in $s$:
\[
triggered(s,a_c)=\bigcup_{C\rhd E\in\cond(a_c),C\subseteq s} E,
\]

The result of applying action $a_c$ in state $s$ is $\theta(s,a_c)=\{s\setminus\eff_c^-(s,a))\cup\eff_c^+(s,a)\}$, where $\eff_c^-(s,a)\subseteq triggered(s,a)$ and $\eff_c^+(s,a)\subseteq triggered(s,a)$ are, respectively, the triggered {\em negative} and {\em positive} effects.


\subsection{The observation model}
Given a classical planning problem $P=\tup{F,A,I,G}$, a plan $\pi$ and a trajectory $\tau(\pi,s_0)$, we define the \emph{observation of the trajectory} as sequence of partial states that represents the observation from the execution of $\pi$ in $P$. Formally, $\mathcal{O}(\tau)=\tup{s_0^o,s_1^o \ldots , s_m^o}$ where $s_0^o=I$.

A partially observable state $s_i^o$ is one in which $|s_i^o| < |F|$; i.e., a state in which at least a fluent of $F$ is not observable. Note that this definition also comprises the case $|s_i^o| = 0$, when the state is fully unobservable. Whatever the sequence of observed states of $\mathcal{O}(\tau)$ is, it must be consistent with the sequence of states of $\tau(\pi,s_0)$, meaning that $\forall i, s_i^o \subseteq s_i$. In practice, the number of observed states, $m$, range from 1 (the initial state, at least), to $|\pi|+1$, and the observed intermediate states will comprise a number of fluents between $[1,|F|]$.

We assume a bijective monotone mapping between actions/states of trajectories and observations~\cite{ramirez2009plan}, thus also granting the inverse consistency relationship (the trajectory is a superset of the observation). Therefore, transiting between two consecutive observed states in $\mathcal{O}(\tau)$ may require the execution of more than a single action ($\theta(s_i^o,\tup{a_1,\ldots,a_k})=s_{i+1}^o$, where ${\small k\geq 1}$ is unknown but finite. In other words, having $\mathcal{O}(\tau)$ does not imply knowing the actual length of $\pi$.

\subsection{Conformant planning}
{\em Conformant planning} refers to planning with incomplete information about the initial state, no sensing, and where goals have to be achieved with certainty (despite the uncertainty of the initial state)~\cite{smith1998conformant,goldman1996expressive}.

Syntactically, conformant planning problems are expressed in compact form through a set of state variables. A {\em conformant planning problem} is then defined as a tuple $P_c=\tup{F,A,\Upsilon,G}$ where $F$, $A$ and $G$ are the set of fluents, actions and goals (as previously defined for the classical planing model). Now $\Upsilon$ is a set of clauses over literals $l=f$ or $l=\neg f$ (for $f\in F$) that define the set of possible initial states. 

A solution to a conformant planning problem is an action sequence that maps each possible initial state into a goal state. More precisely, an action sequence $\pi=\tup{a_1, \ldots, a_n}$ is a {\em conformant plan} for $P_c$ iff for each possible {\em trajectory} $\tau(\pi,s_0)=\tup{s_0, a_1, s_1, \ldots, a_n, s_n}$, such that $s_0$ is a valuation of the fluents in $F$ that satisfies $\Upsilon$, then the $\tau(\pi,s_0)$ trajectory reaches a final state $G \subseteq s_n$.



\section{Learning {\em the least commitment} action model from state observations}
Now we are ready to formalize the learning of the {\em the least commitment} action model from state observations and our approach to address it via {\em conformant planning}. 

\subsection{The {\em least commitment} action model}
The task of computing {\em the least commitment} action model is defined as a tuple $\tup{P,M,\mathcal{O}}$ where:

\begin{itemize}
\item $P=\tup{F,A[\cdot],I,G[\cdot]}$ is a planning problem where $A[\cdot]$ is a set of actions. For each $a\in A[\cdot]$, the semantics of $a$ is unknown; i.e. the functions $\rho$ and/or $\theta$ of $a$ are undefined. The set of goal conditions $G[\cdot]$ is also unknown.
\item $M$ is the set of different planning models for the actions in $A[\cdot]$. A model $\mathcal{M}\in M$ defines the semantics of every action in $A[\cdot]$. Planning models differ in the $\tup{\rho,\theta}$ functions of the actions but they all use the same set of state variables $F$.
\item $\mathcal{O}(\tau)$ is a sequence of state observations coming from the observation of a trajectory $\tau(\pi,s_0)$ produced by the execution of certain unknown plan $\pi$.
\end{itemize}

The {\em solution} to this task is {\em the least commitment} action model which defines the smallest subset of models $M^*\subseteq M$ that is {\em conformant} with the input observation $\mathcal{O}(\tau)$.

\subsection{The space of possible action models}
This work focuses on the lerning of action models that are specified as \strips\ action schema. \strips\ action schemata provide a compact representation for specifying action models. {\em A \strips\ action schema} $\xi$ is defined by four lists: A list of {\em parameters} $pars(\xi)$, and three list of predicates (namely $pre(\xi)$, $del(\xi)$ and $add(\xi)$) that shape the kind of fluents that can appear in the {\em preconditions}, {\em negative effects} and {\em positive effects} of the actions induced from that schema.

\begin{definition}[Comparable \strips\ action schemata]
Two \strips\ schemata $\xi$ and $\xi'$ are {\bf comparable} iff $pars(\xi)=pars(\xi')$, i.e, both share the same list of parameters.\footnote{In \strips\ models, $pars(\xi)=pars(\xi')$ implies the number of parameters must be the same. For other planning models that allow object typing, the equality implies that parameters share the same type}
\end{definition}

For instance, the {\small\tt stack(?v1,?v2)} and {\small\tt unstack(?v1,?v2)} schemata from a four operator {\em blocksworld}~\cite{slaney2001blocks} are {\em comparable} while {\small\tt stack(?v1,?v2)} and {\small\tt pickup(?v1)} are not. Last but not least, we say that two \strips\ models $\mathcal{M}$ and $\mathcal{M}'$ are {\em comparable} iff there exists a bijective function that maps every action schema $\xi\in\mathcal{M}$ to a comparable schemata $\xi'\in\mathcal{M'}$ and vice versa.

Let be $\Psi$ the set of {\em predicates} that shape the propositional state variables $F$, and a list of {\em parameters} $pars(\xi)$. The set of elements that can appear in $pre(\xi)$, $del(\xi)$ and $add(\xi)$ of the \strips\ action schema $\xi$ is given by FOL interpretations of $\Psi$ over the parameters $pars(\xi)$. We denote this set of FOL interpretations as ${\mathcal I}_{\Psi,\xi}$. 

Despite any element of ${\mathcal I}_{\Psi,\xi}$ can {\em a priori} appear in the $pre(\xi)$, $del(\xi)$ and $add(\xi)$ of schema $\xi$, the space of possible \strips\ schemata is constrained by a set ${\mathcal C}$ that includes:

\begin{enumerate}
\item {\em Syntactic constraints}. \strips\ constraints require $del(\xi)\subseteq pre(\xi)$, $del(\xi)\cap add(\xi)=\emptyset$ and $pre(\xi)\cap add(\xi)=\emptyset$. Considering exclusively these syntactic constraints, the size of the space of possible \strips\ schemata is given by $2^{2\times|{\mathcal I}_{\Psi,\xi}|}$. 

\item {\em Domain-specific constraints}. One can introduce domain-specific knowledge to constrain further the space of possible schemata. For instance, in the {\em blocksworld} one can argue that {\small\tt on($v_1$,$v_1$)} and {\small\tt on($v_2$,$v_2$)} will not appear in the $pre(\xi)$, $del(\xi)$ and $add(\xi)$ lists of an action schema $\xi$ because of the semantic of the {\tt\small on} predicate (i.e. only one block can be on top of another block). Invariants constraining the space of possible states in a given domain belong also to this group~\cite{fox1998automatic}. 
\end{enumerate}

\begin{definition}[Well-defined \strips\ action schemata]
Given a set of {\em predicates} $\Psi$, a list of action {\em parameters} $pars(\xi)$, and set of FOL constraints ${\mathcal C}$, $\xi$ is a {\bf well-defined \strips\ action schema} iff its three lists $pre(\xi)\subseteq {\mathcal I}_{\Psi,\xi}$, $del(\xi)\subseteq{\mathcal I}_{\Psi,\xi}$ and $add(\xi)\subseteq{\mathcal I}_{\Psi,\xi}$ only contain elements in ${\mathcal I}_{\Psi,\xi}$ and they satisfy all the constraints in ${\mathcal C}$.
\end{definition}

We say a planning model $\mathcal{M}$ is {\em well-defined} if all its \strips\ action schemata are {\em well-defined}.

\begin{enumerate}
\item[3.] {\em Observation constraints}. A sequence of state observations $\mathcal{O}(\tau)$ constraints further the space of possible action schemata. This \emph{semantic knowledge} included in the observations introduce a third type of constraints and can also be added to the set $\mathcal{C}$.
\end{enumerate}


\subsection{Learning {\em the least commitment} model with conformant planning}
Given a classical planning problem $P=\tup{F,A[\cdot],I,G[\cdot]}$ and a sequence of state observations $\mathcal{O}(\tau)$ coming from the observation of a $\tau(\pi,I)$ trajectory, we show here that we can build a {\em conformant planning problem} $P_c$ in linear time and space and whose solution is a plan that induces the {\em least commitment} model that is conformant with $\mathcal{O}(\tau)$.

In more detail, our compilation defines a {\em conformant planning problem} $P_c=\tup{F_c,A_c,\Upsilon,G}$ such that:
\begin{itemize}
\item The set of fluents $F_c$ extends $F$ with two new sets of fluents:
      \begin{itemize}
      \item $\{test_j\}_{1\leq j\leq m}$, indicating the state observation $s_j\in\mathcal{O}(\tau)$ where the action model is validated
      \item The fluents $[pre|del|add]\_e\_\xi$ such that $e\in{\mathcal I}_{\Psi,\xi}$ for a propositional encoding of the {\em preconditions}, {\em negative} and {\em positive} effects of schema $\xi$. Figure~\ref{fig:propositional} shows the propositional encoding of the unstack action from the blocksworld.
      \end {itemize}



\begin{figure}
  \begin{tiny}  
  \begin{verbatim}
(:action stack
   :parameters (?x ?y)
   :precondition (and (holding ?x) (clear ?y))
   :effect (and (not (holding ?x)) (not (clear ?y))
                (clear ?x) (handempty) (on ?x ?y)))


(pre_holding_v1_stack) (pre_clear_v2_stack)
(eff_holding_v1_stack) (eff_clear_v2_stack)
(eff_clear_v1_stack) (eff_handempty_stack) (eff_on_v1_v2_stack)
  \end{verbatim}           
  \end{tiny}  
 \caption{\small PDDL encoding of the {\tt\small stack(?v1,?v2)} schema and our propositional representation for this same action.}
\label{fig:propositional}
\end{figure}



      \item The set of actions $A_c$ contains now actions of three different kinds:
\begin{itemize}
      \item Actions for {\em committing} {\small $pre\_e\_\xi$} fluents to a positive and a negative value.
\begin{small}
\begin{align*}
\hspace*{7pt}\pre(\mathsf{set\top\_pre\_e\_\xi})=&\{\},\\
\cond(\mathsf{set\top\_pre\_e\_\xi})=&\{pre\_e\_\xi\}\rhd\{pre\_e\_\xi\},\\
                                    &\{\neg pre\_e\_\xi\}\rhd\{pre\_e\_\xi\}.\\
\hspace*{7pt}\pre(\mathsf{set\bot\_pre\_e\_\xi})=&\{\},\\
\cond(\mathsf{set\bot\_pre\_e\_\xi})=&\{pre\_e\_\xi\}\rhd\{\neg pre\_e\_\xi\},\\
                                    &\{\neg pre\_e\_\xi\}\rhd\{\neg pre\_e\_\xi\}.                                    
\end{align*}
\end{small}
In addition, similar actions are defined for {\em committing} {\small $eff\_e\_\xi$} fluents to a positive value and for {\em committing} {\small $pre\_e\_\xi$} fluents to a negative value.

      \item Actions for {\em validating} the edited models at the $s_j$ observed states, {\tt\small $0\leq j< m$}
\begin{small}
\begin{align*}
\hspace*{7pt}\pre(\mathsf{validate_{j}})=&s_j\cup\{test_{j-1}\},\\
\cond(\mathsf{validate_{j}})=&\{\emptyset\}\rhd\{\neg test_{j-1}, test_j,\\
                            &\{mode_{edit}\}\rhd\{\neg mode_{edit}, mode_{val}\}.
\end{align*}
\end{small}

      \item Actions whose semantics is given by the value of the {\small $pre\_e\_\xi$}, {\small $pre\_e\_\xi$} fluents at the current state. Given an operator schema $\xi\in\mathcal{M}$ its {\em editable} version is formalized as:
\begin{small}  
\begin{align*}
\hspace*{7pt}\pre(\mathsf{editable_{\xi}})=&\{pre\_e\_\xi\implies e\}_{\forall e\in{\mathcal I}_{\Psi,\xi}}\\
\cond(\mathsf{editable_{\xi}})=&\{pre\_e\_\xi, eff\_e\_\xi\}\rhd\{\neg e\}_{\forall e\in{\mathcal I}_{\Psi,\xi}},\\
&\{\neg pre\_e\_\xi, eff\_e\_\xi\}\rhd\{e\}_{\forall e\in{\mathcal I}_{\Psi,\xi}}.
\end{align*}
\end{small}
Figure~\ref{fig:editable} shows the PDDL encoding of the editable version of the {\tt\small stack(?v1,?v2)} schema. Note that this editable schema, when the fluents {\tiny\tt (pre\_holding\_v1\_stack) (pre\_clear\_v2\_stack) (eff\_holding\_v1\_stack) (eff\_clear\_v2\_stack) (eff\_clear\_v1\_stack) (eff\_handempty\_stack) (eff\_on\_v1\_v2\_stack)} hold, it behaves exactly as defined in Figure~\ref{fig:propositional}.     
\end{itemize}
\item The new goals are $G_c=\{test_m\}$ .
\end{itemize}


\begin{figure}
  \begin{tiny}  
  \begin{verbatim}
(:action stack
 :parameters (?o1 - object ?o2 - object)
 :precondition
   (and (or (not (pre_on_v1_v1_stack)) (on ?o1 ?o1))
        (or (not (pre_on_v1_v2_stack)) (on ?o1 ?o2))
        (or (not (pre_on_v2_v1_stack)) (on ?o2 ?o1))
        (or (not (pre_on_v2_v2_stack)) (on ?o2 ?o2))
        (or (not (pre_ontable_v1_stack)) (ontable ?o1))
        (or (not (pre_ontable_v2_stack)) (ontable ?o2))
        (or (not (pre_clear_v1_stack)) (clear ?o1))
        (or (not (pre_clear_v2_stack)) (clear ?o2))
        (or (not (pre_holding_v1_stack)) (holding ?o1))
        (or (not (pre_holding_v2_stack)) (holding ?o2))
        (or (not (pre_handempty_stack)) (handempty)))
 :effect (and
   (when (and (pre_on_v1_v1_stack)(eff_on_v1_v1_stack)) (not (on ?o1 ?o1)))
   (when (and (pre_on_v1_v2_stack)(eff_on_v1_v2_stack)) (not (on ?o1 ?o2)))
   (when (and (pre_on_v2_v1_stack)(eff_on_v2_v1_stack)) (not (on ?o2 ?o1)))
   (when (and (pre_on_v2_v2_stack)(eff_on_v2_v2_stack)) (not (on ?o2 ?o2)))
   (when (and (pre_ontable_v1_stack)(eff_ontable_v1_stack)) (not (ontable ?o1)))
   (when (and (pre_ontable_v2_stack)(eff_ontable_v2_stack)) (not (ontable ?o2)))
   (when (and (pre_clear_v1_stack)(eff_clear_v1_stack)) (not (clear ?o1)))
   (when (and (pre_clear_v2_stack)(eff_clear_v2_stack)) (not (clear ?o2)))
   (when (and (pre_holding_v1_stack)(eff_holding_v1_stack)) (not (holding ?o1)))
   (when (and (pre_holding_v2_stack)(eff_holding_v2_stack)) (not (holding ?o2)))
   (when (and (pre_handempty_stack)(eff_handempty_stack)) (not (handempty)))
   (when (and (not(pre_on_v1_v1_stack))(eff_on_v1_v1_stack)) (on ?o1 ?o1))
   (when (and (not(pre_on_v1_v2_stack))(eff_on_v1_v2_stack)) (on ?o1 ?o2))
   (when (and (not(pre_on_v2_v1_stack))(eff_on_v2_v1_stack)) (on ?o2 ?o1))
   (when (and (not(pre_on_v2_v2_stack))(eff_on_v2_v2_stack)) (on ?o2 ?o2))
   (when (and (not(pre_ontable_v1_stack))(eff_ontable_v1_stack)) (ontable ?o1))
   (when (and (not(pre_ontable_v2_stack))(eff_ontable_v2_stack)) (ontable ?o2))
   (when (and (not(pre_clear_v1_stack))(eff_clear_v1_stack)) (clear ?o1))
   (when (and (not(pre_clear_v2_stack))(eff_clear_v2_stack)) (clear ?o2))
   (when (and (not(pre_holding_v1_stack))(eff_holding_v1_stack)) (holding ?o1))
   (when (and (not(pre_holding_v2_stack))(eff_holding_v2_stack)) (holding ?o2))
   (when (and (not(pre_handempty_stack))(eff_handempty_stack)) (handempty))))
  \end{verbatim}           
  \end{tiny}  
 \caption{\small PDDL encoding of the editable version of the {\tt\small stack(?v1,?v2)} schema.}
\label{fig:editable}
\end{figure}

Given a plan $\pi$ that solves the {\em conformant planning} problem $P_c$ that results from our compilation then, the {\em least commitment} model that is conformant with $\mathcal{O}(\tau)$ is extracted in linear time from the last state reached by $\pi$.


\subsection{Compilation properties}


\section{Evaluation}



\section{Conclusions}



%% The file named.bst is a bibliography style file for BibTeX 0.99c
\bibliographystyle{named}
\bibliography{planlearnbibliography.bib}

\end{document}

