%%%% ijcai19.tex

\typeout{IJCAI-19 Instructions for Authors}

% These are the instructions for authors for IJCAI-19.

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in
% The file ijcai19.sty is NOT the same than previous years'
\usepackage{ijcai19}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algorithmic}
\urlstyle{same}

%%%%%%%%%%%%%%%%%% Added for this paper
\usepackage{ wasysym }
\newcommand{\tup}[1]{{\langle #1 \rangle}}
\newcommand{\pre}{\mathsf{pre}}     % precondition
\newcommand{\del}{\mathsf{del}}     % effect
\newcommand{\add}{\mathsf{add}}     % effect
\newcommand{\eff}{\mathsf{eff}}     % effect
\newcommand{\cond}{\mathsf{cond}}   % conditional effect
\newcommand{\true}{\mathsf{true}}   % true
\newcommand{\false}{\mathsf{false}} % false
\newcommand{\PE}{\mathrm{PE}}     % precondition
\newcommand{\strips}{\textsc{Strips}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}

%%%%%%%%%%%%%55


% the following package is optional:
%\usepackage{latexsym} 

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.

\title{Computing {\em the least commitment} action model from state observations}

% Single author syntax
%\author{
%    Sarit Kraus
%    \affiliations
%    Department of Computer Science, Bar-Ilan University, Israel \emails
%    pcchair@ijcai19.org
%}

% Multiple author syntax (remove the single-author syntax above and the \iffalse ... \fi here)
% Check the ijcai19-multiauthor.tex file for detailed instructions
\author{
Diego Aineto$^1$\and
Sergio Jim\'enez$^1$\and
Eva Onaindia$^1$\And
\and
Blai Bonet$^2$
\affiliations
$^1${\small Departamento de Sistemas Inform\'aticos y Computaci\'on. Universitat Polit\`ecnica de Val\`encia. Valencia, Spain}\\
$^2${\small Departamento de Computaci\'on. Universidad Sim\'on Bol√≠var. Caracas, Venezuela}
\emails
{\scriptsize \{dieaigar,serjice,onaindia\}@dsic.upv.es, bonet@usb.ve}}



\begin{document}

\maketitle

\begin{abstract}
  
\end{abstract}

\section{Introduction}
Given a sequence of partially observed states, this paper formalizes the task of computing {\em the least commitment} action model that can explain the given observation. This task is of interest because it allows the incremental learning of action models from arbitrary large sets of state observations.

In addition, the paper introduces a new method to compute {\em the least commitment} action model from a sequence of state observations. The method assumes that action models are specified as \strips\ action schema and it builds on top of off-the-shelf algorithms for {\em conformant planning}.



\section{Background}
This section formalizes the model of {\em classical planning with conditional effects}, the {\em conformant planning} model, and the kind of input observations for the computation of {\em the least commitment} action model.  

\subsection{Classical planning with conditional effects}
Let $F$ be the set of {\em fluents} or {\em state variables} (propositional variables). A {\em literal} $l$ is a valuation of a fluent $f\in F$, i.e. either~$l=f$ or $l=\neg f$. $L$ is a set of literals that represents a partial assignment of values to fluents, and $\mathcal{L}(F)$ is the set of all literals sets on $F$, i.e.~all partial assignments of values to fluents. A {\em state} $s$ is a full assignment of values to fluents. We explicitly include negative literals $\neg f$ in states s.t. $|s|=|F|$ and the size of the state space is $2^{|F|}$.

A {\em planning frame} is a tuple $\Phi=\tup{F,A}$, where $F$ is a set of fluents and $A$ is a set of \emph{actions}. An action $a\in A$ is defined with {\em preconditions}, $\pre(a)\in\mathcal{L}(F)$, {\em positive effects}, $\eff^+(a)\in\mathcal{L}(F)$, and {\em negative effects} $\eff^-(a)\in\mathcal{L}(F)$. The semantics of actions $a\in A$ is specified with two functions: $\rho(s,a)$ denotes whether action $a$ is {\em applicable} in a state $s$ and $\theta(s,a)$ denotes the {\em successor state} that results of applying action $a$ in a state $s$. Then, $\rho(s,a)$ holds iff $\pre(a)\subseteq s$. And the result of applying $a$ in $s$ is $\theta(s,a)=\{s\setminus\eff^-(a))\cup\eff^+(a)\}$.

A {\em classical planning problem} is a tuple $P=\tup{F,A,I,G}$, where $I$ is the initial state and $G\in\mathcal{L}(F)$ is the set of goal conditions over the state variables. A {\em plan} $\pi$ is an action sequence $\pi=\tup{a_1, \ldots, a_n}$, with $|\pi|=n$ denoting its {\em plan length}. The execution of $\pi$ in the initial state $I$ of $P$ induces a {\em trajectory} $\tau(\pi,s_0)=\tup{s_0, a_1, s_1, \ldots, a_n, s_n}$ such that $s_0=I$ and, for each {\small $1\leq i\leq n$}, it holds $\rho(s_{i-1},a_i)$ and $s_i=\theta(s_{i-1},a_i)$. A plan $\pi$ solves $P$ iff the induced {\em trajectory} $\tau(\pi,s_0)$ reaches a final state $G \subseteq s_n$. A solution plan is optimal iff its length is minimal.

An action $a_c\in A$ with conditional effects is defined as a set of preconditions $\pre(a_c)\in\mathcal{L}(F)$ and a set of {\em conditional effects} $\cond(a_c)$. Each conditional effect $C\rhd E\in\cond(a_c)$ is composed of two sets of literals: $C\in\mathcal{L}(F)$, the {\em condition}, and $E\in\mathcal{L}(F)$, the {\em effect}. An action $a_c$ is applicable in a state $s$ if $\rho(s,a_c)$ is true, and the {\em triggered effects} resulting from the action application are the effects whose conditions hold in $s$:
\[
triggered(s,a_c)=\bigcup_{C\rhd E\in\cond(a_c),C\subseteq s} E,
\]

The result of applying action $a_c$ in state $s$ is $\theta(s,a_c)=\{s\setminus\eff_c^-(s,a))\cup\eff_c^+(s,a)\}$, where $\eff_c^-(s,a)\subseteq triggered(s,a)$ and $\eff_c^+(s,a)\subseteq triggered(s,a)$ are, respectively, the triggered {\em negative} and {\em positive} effects.


\subsection{The observation model}
Given a classical planning problem $P=\tup{F,A,I,G}$, a plan $\pi$ and a trajectory $\tau(\pi,s_0)$, we define the \emph{observation of the trajectory} as sequence of partial states that represents the observation from the execution of $\pi$ in $P$. Formally, $\mathcal{O}(\tau)=\tup{s_0^o,s_1^o \ldots , s_m^o}$ where $s_0^o=I$.

A partially observable state $s_i^o$ is one in which $|s_i^o| < |F|$; i.e., a state in which at least a fluent of $F$ is not observable. Note that this definition also comprises the case $|s_i^o| = 0$, when the state is fully unobservable. Whatever the sequence of observed states of $\mathcal{O}(\tau)$ is, it must be consistent with the sequence of states of $\tau(\pi,s_0)$, meaning that $\forall i, s_i^o \subseteq s_i$. In practice, the number of observed states, $m$, ranges from 1 (the initial state, at least), to $|\pi|+1$, and the observed intermediate states will comprise a number of fluents between $[1,|F|]$.

We assume a bijective monotone mapping between trajectories and observations~\cite{ramirez2009plan}, thus also granting the inverse consistency relationship (the trajectory is a superset of the observation). Therefore, transiting between two consecutive observed states in $\mathcal{O}(\tau)$ may require the execution of more than a single action ($\theta(s_i^o,\tup{a_1,\ldots,a_k})=s_{i+1}^o$, where ${\small k\geq 1}$ is unknown but finite. In other words, having $\mathcal{O}(\tau)$ does not imply knowing the actual length of $\pi$.

\subsection{Conformant planning}
{\em Conformant planning} is planning with incomplete information about the initial state, no sensing, and where goals have to be achieved with certainty (despite this uncertainty of the initial state)~\cite{smith1998conformant,goldman1996expressive}.

Syntactically, conformant planning problems are expressed in compact form through a set of state variables. A {\em conformant planning problem} can be defined as a tuple $P_c=\tup{F,A,\Upsilon,G}$ where $F$, $A$ and $G$ are the set of {\em fluents}, {\em actions} and {\em goals} (as previously defined for {\em classical planning}). Now $\Upsilon$ is a set of clauses over literals $l=f$ or $l=\neg f$ (for $f\in F$) that define the set of possible initial states. 

A solution to a conformant planning problem is an action sequence that maps each possible initial state into a goal state. More precisely, an action sequence $\pi=\tup{a_1, \ldots, a_n}$ is a {\em conformant plan} for $P_c$ iff for each possible {\em trajectory} $\tau(\pi,s_0)=\tup{s_0, a_1, s_1, \ldots, a_n, s_n}$, such that $s_0$ is a valuation of the fluents in $F$ that satisfies $\Upsilon$, then the $\tau(\pi,s_0)$ trajectory reaches a final state $G \subseteq s_n$ in which all the goal conditions are met.



\section{Learning {\em the least commitment} action model from state observations}
This section formalizes the notion of {\em the least commitment action model} that is able to {\em explain} a sequence of state observations and our approach to compute such model via {\em conformant planning}. 

\subsection{The {\em least commitment} action model}
The task of computing {\em the least commitment} action model is defined as a tuple $\tup{P,M,\mathcal{O}}$ where:
\begin{itemize}
\item $P=\tup{F,A[\cdot],I,G}$ is a planning problem where $A[\cdot]$ is a set of actions. For each $a\in A[\cdot]$, the semantics of $a$ is unknown; i.e. the functions $\rho$ and/or $\theta$ of $a$ are undefined. 
\item $M$ is the set of possible models for the actions in $A[\cdot]$. A model $\mathcal{M}\in M$ defines the semantics of every action in $A[\cdot]$. Planning models $\mathcal{M}\in M$ differ in the $\tup{\rho,\theta}$ functions of the actions but they all use the same set of state variables $F$.
\item $\mathcal{O}(\tau)$ is a sequence of partial states coming from the observation of a trajectory $\tau(\pi,s_0)$ produced by the execution of certain unknown plan $\pi$ that solves $P$.
\end{itemize}

The {\em solution} to this task is {\em the least commitment} action model but, before formalizing it, we introduce the following necessary definition.

\begin{definition}[Explanation of an observation]
Given a model $\mathcal{M}\in M$ for the actions $A[\cdot]$ in $P$, and a sequence of partially observed states $\mathcal{O}(\tau)$, we say that {\em the model explains the observation}, that we denote by $\mathcal{M}\mapsto\mathcal{O}(\tau)$, iff there exists a plan $\pi$ that solves $P$ and that it is consistent with $\pi$. We say that $\pi$ is the {\em best explanation} for $\mathcal{O}(\tau)$ iff, in additon, $\pi$ is optimal.
\end{definition}

Now we are ready to define {\em the least commitment} action model as the largest subset of models $M^*\subseteq M$ such that every model $\mathcal{M}\in M^*$ explains the input observation $\mathcal{O}(\tau)$.


\subsection{The space of possible action models}
In spite of previous definitions are general, this work focuses on action models that are specified as \strips\ action schemata. \strips\ action schemata provide a compact representation for specifying action models. {\em A \strips\ action schema} $\xi$ is defined by four lists: A list of {\em parameters} $pars(\xi)$, and three list of predicates (namely $pre(\xi)$, $del(\xi)$ and $add(\xi)$) that shape the kind of fluents that can appear in the {\em preconditions}, {\em negative effects} and {\em positive effects} of the actions induced from that schema.

Let be $\Psi$ the set of {\em predicates} that shape the propositional state variables $F$, and a list of {\em parameters} $pars(\xi)$. The set of elements that can appear in $pre(\xi)$, $del(\xi)$ and $add(\xi)$ of the \strips\ action schema $\xi$ is given by FOL interpretations of $\Psi$ over the parameters $pars(\xi)$. We denote this set of FOL interpretations as ${\mathcal I}_{\Psi,\xi}$. 

Despite any element of ${\mathcal I}_{\Psi,\xi}$ can {\em a priori} appear in the $pre(\xi)$, $del(\xi)$ and $add(\xi)$ of schema $\xi$, the space of possible \strips\ schemata is constrained by a set ${\mathcal C}$ that includes:

\begin{enumerate}
\item {\em Syntactic constraints}. \strips\ constraints require $del(\xi)\subseteq pre(\xi)$, $del(\xi)\cap add(\xi)=\emptyset$ and $pre(\xi)\cap add(\xi)=\emptyset$. Considering exclusively these syntactic constraints, the size of the space of possible \strips\ schemata is given by $2^{2\times|{\mathcal I}_{\Psi,\xi}|}$. 

\item {\em Domain-specific constraints}. One can introduce domain-specific knowledge to constrain further the space of possible schemata. For instance, in the {\em blocksworld} one can argue that {\small\tt on($v_1$,$v_1$)} and {\small\tt on($v_2$,$v_2$)} will not appear in the $pre(\xi)$, $del(\xi)$ and $add(\xi)$ lists of an action schema $\xi$ because of the semantic of the {\tt\small on} predicate (i.e. only one block can be on top of another block). As a rule of thumb, {\it invariants} constraining the possible states of a given planning domain belong to this class of constraints~\cite{fox1998automatic}. 
\end{enumerate}

\begin{definition}[Well-defined \strips\ action schemata]
Given a set of {\em predicates} $\Psi$, a list of action {\em parameters} $pars(\xi)$, and set of FOL constraints ${\mathcal C}$, $\xi$ is a {\bf well-defined \strips\ action schema} iff its three lists $pre(\xi)\subseteq {\mathcal I}_{\Psi,\xi}$, $del(\xi)\subseteq{\mathcal I}_{\Psi,\xi}$ and $add(\xi)\subseteq{\mathcal I}_{\Psi,\xi}$ only contain elements in ${\mathcal I}_{\Psi,\xi}$ and they satisfy all the constraints in ${\mathcal C}$.
\end{definition}

We say a planning model $\mathcal{M}$ is {\em well-defined} if all its \strips\ action schemata are {\em well-defined}.

\begin{enumerate}
\item[3.] {\em Observation constraints}. A sequence of state observations $\mathcal{O}(\tau)$ constraints further the space of possible action schemata. This \emph{semantic knowledge} included in the observations introduce a third type of constraints and can also be added to the set $\mathcal{C}$.
\end{enumerate}


\subsection{Learning {\em the least commitment} model with conformant planning}
Given a classical planning problem $P=\tup{F,A[\cdot],I,G[\cdot]}$ and a sequence of state observations $\mathcal{O}(\tau)$ coming from the observation of a $\tau(\pi,I)$ trajectory, we show here that we can build a {\em conformant planning problem} $P_c$ in linear time and space and whose solution is a plan that induces the {\em least commitment} model that is conformant with $\mathcal{O}(\tau)$.

In more detail, our compilation defines a {\em conformant planning problem} $P_c=\tup{F_c,A_c,\Upsilon,G}$ such that:
\begin{itemize}
\item The set of fluents $F_c$ extends $F$ with two new sets of fluents:
      \begin{itemize}
      \item $\{test_j\}_{1\leq j\leq m}$, indicating the state observation $s_j\in\mathcal{O}(\tau)$ where the action model is validated
      \item The fluents $[pre|del|add]\_e\_\xi$ such that $e\in{\mathcal I}_{\Psi,\xi}$ for a propositional encoding of the {\em preconditions}, {\em negative} and {\em positive} effects of schema $\xi$. Figure~\ref{fig:propositional} shows the propositional encoding of the unstack action from the blocksworld.
      \end {itemize}



\begin{figure}
  \begin{tiny}  
  \begin{verbatim}
(:action stack
   :parameters (?x ?y)
   :precondition (and (holding ?x) (clear ?y))
   :effect (and (not (holding ?x)) (not (clear ?y))
                (clear ?x) (handempty) (on ?x ?y)))


(pre_holding_v1_stack) (pre_clear_v2_stack)
(eff_holding_v1_stack) (eff_clear_v2_stack)
(eff_clear_v1_stack) (eff_handempty_stack) (eff_on_v1_v2_stack)
  \end{verbatim}           
  \end{tiny}  
 \caption{\small PDDL encoding of the {\tt\small stack(?v1,?v2)} schema and our propositional representation for this same action.}
\label{fig:propositional}
\end{figure}



      \item The set of actions $A_c$ contains now actions of three different kinds:
\begin{itemize}
      \item Actions for {\em committing} {\small $pre\_e\_\xi$} fluents to a positive and a negative value.
\begin{small}
\begin{align*}
\hspace*{7pt}\pre(\mathsf{set\top\_pre\_e\_\xi})=&\{\},\\
\cond(\mathsf{set\top\_pre\_e\_\xi})=&\{pre\_e\_\xi\}\rhd\{pre\_e\_\xi\},\\
                                    &\{\neg pre\_e\_\xi\}\rhd\{pre\_e\_\xi\}.\\
\hspace*{7pt}\pre(\mathsf{set\bot\_pre\_e\_\xi})=&\{\},\\
\cond(\mathsf{set\bot\_pre\_e\_\xi})=&\{pre\_e\_\xi\}\rhd\{\neg pre\_e\_\xi\},\\
                                    &\{\neg pre\_e\_\xi\}\rhd\{\neg pre\_e\_\xi\}.                                    
\end{align*}
\end{small}
In addition, similar actions are defined for {\em committing} {\small $eff\_e\_\xi$} fluents to a positive value and for {\em committing} {\small $pre\_e\_\xi$} fluents to a negative value.

      \item Actions for {\em validating} the edited models at the $s_j$ observed states, {\tt\small $0\leq j< m$}
\begin{small}
\begin{align*}
\hspace*{7pt}\pre(\mathsf{validate_{j}})=&s_j\cup\{test_{j-1}\},\\
\cond(\mathsf{validate_{j}})=&\{\emptyset\}\rhd\{\neg test_{j-1}, test_j,\\
                            &\{mode_{edit}\}\rhd\{\neg mode_{edit}, mode_{val}\}.
\end{align*}
\end{small}

      \item Actions whose semantics is given by the value of the {\small $pre\_e\_\xi$}, {\small $pre\_e\_\xi$} fluents at the current state. Given an operator schema $\xi\in\mathcal{M}$ its {\em editable} version is formalized as:
\begin{small}  
\begin{align*}
\hspace*{7pt}\pre(\mathsf{editable_{\xi}})=&\{pre\_e\_\xi\implies e\}_{\forall e\in{\mathcal I}_{\Psi,\xi}}\\
\cond(\mathsf{editable_{\xi}})=&\{pre\_e\_\xi, eff\_e\_\xi\}\rhd\{\neg e\}_{\forall e\in{\mathcal I}_{\Psi,\xi}},\\
&\{\neg pre\_e\_\xi, eff\_e\_\xi\}\rhd\{e\}_{\forall e\in{\mathcal I}_{\Psi,\xi}}.
\end{align*}
\end{small}
Figure~\ref{fig:editable} shows the PDDL encoding of the editable version of the {\tt\small stack(?v1,?v2)} schema. Note that this editable schema, when the fluents {\tiny\tt (pre\_holding\_v1\_stack) (pre\_clear\_v2\_stack) (eff\_holding\_v1\_stack) (eff\_clear\_v2\_stack) (eff\_clear\_v1\_stack) (eff\_handempty\_stack) (eff\_on\_v1\_v2\_stack)} hold, it behaves exactly as defined in Figure~\ref{fig:propositional}.     
\end{itemize}
\item The new goals are $G_c=\{test_m\}$ .
\end{itemize}


\begin{figure}
  \begin{tiny}  
  \begin{verbatim}
(:action stack
 :parameters (?o1 - object ?o2 - object)
 :precondition
   (and (or (not (pre_on_v1_v1_stack)) (on ?o1 ?o1))
        (or (not (pre_on_v1_v2_stack)) (on ?o1 ?o2))
        (or (not (pre_on_v2_v1_stack)) (on ?o2 ?o1))
        (or (not (pre_on_v2_v2_stack)) (on ?o2 ?o2))
        (or (not (pre_ontable_v1_stack)) (ontable ?o1))
        (or (not (pre_ontable_v2_stack)) (ontable ?o2))
        (or (not (pre_clear_v1_stack)) (clear ?o1))
        (or (not (pre_clear_v2_stack)) (clear ?o2))
        (or (not (pre_holding_v1_stack)) (holding ?o1))
        (or (not (pre_holding_v2_stack)) (holding ?o2))
        (or (not (pre_handempty_stack)) (handempty)))
 :effect (and
   (when (and (pre_on_v1_v1_stack)(eff_on_v1_v1_stack)) (not (on ?o1 ?o1)))
   (when (and (pre_on_v1_v2_stack)(eff_on_v1_v2_stack)) (not (on ?o1 ?o2)))
   (when (and (pre_on_v2_v1_stack)(eff_on_v2_v1_stack)) (not (on ?o2 ?o1)))
   (when (and (pre_on_v2_v2_stack)(eff_on_v2_v2_stack)) (not (on ?o2 ?o2)))
   (when (and (pre_ontable_v1_stack)(eff_ontable_v1_stack)) (not (ontable ?o1)))
   (when (and (pre_ontable_v2_stack)(eff_ontable_v2_stack)) (not (ontable ?o2)))
   (when (and (pre_clear_v1_stack)(eff_clear_v1_stack)) (not (clear ?o1)))
   (when (and (pre_clear_v2_stack)(eff_clear_v2_stack)) (not (clear ?o2)))
   (when (and (pre_holding_v1_stack)(eff_holding_v1_stack)) (not (holding ?o1)))
   (when (and (pre_holding_v2_stack)(eff_holding_v2_stack)) (not (holding ?o2)))
   (when (and (pre_handempty_stack)(eff_handempty_stack)) (not (handempty)))
   (when (and (not(pre_on_v1_v1_stack))(eff_on_v1_v1_stack)) (on ?o1 ?o1))
   (when (and (not(pre_on_v1_v2_stack))(eff_on_v1_v2_stack)) (on ?o1 ?o2))
   (when (and (not(pre_on_v2_v1_stack))(eff_on_v2_v1_stack)) (on ?o2 ?o1))
   (when (and (not(pre_on_v2_v2_stack))(eff_on_v2_v2_stack)) (on ?o2 ?o2))
   (when (and (not(pre_ontable_v1_stack))(eff_ontable_v1_stack)) (ontable ?o1))
   (when (and (not(pre_ontable_v2_stack))(eff_ontable_v2_stack)) (ontable ?o2))
   (when (and (not(pre_clear_v1_stack))(eff_clear_v1_stack)) (clear ?o1))
   (when (and (not(pre_clear_v2_stack))(eff_clear_v2_stack)) (clear ?o2))
   (when (and (not(pre_holding_v1_stack))(eff_holding_v1_stack)) (holding ?o1))
   (when (and (not(pre_holding_v2_stack))(eff_holding_v2_stack)) (holding ?o2))
   (when (and (not(pre_handempty_stack))(eff_handempty_stack)) (handempty))))
  \end{verbatim}           
  \end{tiny}  
 \caption{\small PDDL encoding of the editable version of the {\tt\small stack(?v1,?v2)} schema.}
\label{fig:editable}
\end{figure}

Given a plan $\pi$ that solves the {\em conformant planning} problem $P_c$ that results from our compilation then, the {\em least commitment} model that is conformant with $\mathcal{O}(\tau)$ is extracted in linear time from the last state reached by $\pi$.


\subsection{Compilation properties}


\section{Evaluation}



\section{Conclusions}



%% The file named.bst is a bibliography style file for BibTeX 0.99c
\bibliographystyle{named}
\bibliography{planlearnbibliography.bib}

\end{document}

